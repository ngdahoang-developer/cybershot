<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberShot - Random Shapes</title>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; color: white; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 10; }
        #video-bg { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; z-index: 1; transform: scaleX(-1); }
        .neon-text { text-shadow: 0 0 10px currentColor, 0 0 20px currentColor; }
        .floating-text { position: absolute; pointer-events: none; animation: float 0.8s forwards; font-weight: bold; z-index: 100; font-size: 1.5rem; }
        @keyframes float { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-80px); opacity: 0; } }
    </style>
</head>
<body>
    <video id="video-bg" autoplay playsinline></video>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const AudioEngine = {
            ctx: null,
            init() { if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            play(freq, type = 'sine', dur = 0.1, vol=0.1) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                g.gain.setValueAtTime(vol, this.ctx.currentTime); g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + dur);
                osc.connect(g); g.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + dur);
            }
        };

        
        const geometryCreators = [
            () => new THREE.SphereGeometry(0.4, 32, 32), 
            () => new THREE.BoxGeometry(0.6, 0.6, 0.6),   
            () => new THREE.ConeGeometry(0.4, 0.8, 32),   
            () => new THREE.TorusGeometry(0.3, 0.15, 16, 32), 
            () => new THREE.IcosahedronGeometry(0.45, 0), 
            () => new THREE.TorusKnotGeometry(0.3, 0.1, 64, 8) 
        ];

        const App = () => {
            const [gameState, setGameState] = useState('loading');
            const [score, setScore] = useState(0);
            const [floatingTexts, setFloatingTexts] = useState([]);
            const [CurrentTargetType, setCurrentTargetType] = useState(null);
            
            const sceneRef = useRef(null);
            const gameData = useRef({
                targets: [], lastHandTime: 0, isFiring: false,
                aimPos: new THREE.Vector2(0.5, 0.5), smoothedAim: new THREE.Vector2(0.5, 0.5), calibration: 0
            });

            useEffect(() => {
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                
                scene.add(new THREE.AmbientLight(0xffffff, 0.5), new THREE.DirectionalLight(0xffffff, 1));
                sceneRef.current = { scene, camera, renderer, raycaster: new THREE.Raycaster() };

                const videoElement = document.getElementById('video-bg');
                const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${f}` });
                hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 }); 
                
                hands.onResults(results => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
                        const lm = results.multiHandLandmarks[0];
                        gameData.current.aimPos.set(1 - lm[8].x, lm[8].y);
                        const dist = Math.hypot(lm[4].x - lm[5].x, lm[4].y - lm[5].y);
                        const wasFiring = gameData.current.isFiring;
                        gameData.current.isFiring = dist < 0.07;
                        if (gameData.current.isFiring && !wasFiring && gameState === 'playing') shoot();
                        gameData.current.lastHandTime = performance.now();
                    }
                });

                const mpCam = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({ image: videoElement }); },
                    width: 1280, height: 720
                });
                mpCam.start().then(() => setGameState('calibrating'));

                let lastTime = 0;
                const loop = (now) => {
                    const dt = (now - lastTime) / 1000;
                    lastTime = now;
                    if (sceneRef.current) {
                        const { scene, camera, renderer } = sceneRef.current;
                        const hasHand = (performance.now() - gameData.current.lastHandTime) < 500;

                        if (gameState === 'calibrating') {
                            if (hasHand) {
                                gameData.current.calibration += dt;
                                if (gameData.current.calibration > 1.5) {
                                    setGameState('playing');
                                    AudioEngine.init();
                                    spawnTarget(); 
                                }
                            } else {
                                gameData.current.calibration = Math.max(0, gameData.current.calibration - dt);
                            }
                        }

                        const alpha = gameData.current.isFiring ? 0.1 : 0.3;
                        gameData.current.smoothedAim.lerp(gameData.current.aimPos, alpha);

                        
                        if (gameData.current.targets.length > 0) {
                            const t = gameData.current.targets[0];
                            t.mesh.position.add(t.velocity);
                            t.mesh.rotation.x += dt * 2; t.mesh.rotation.y += dt * 3;
                            
                            
                            if (Math.abs(t.mesh.position.x) > 15 || Math.abs(t.mesh.position.y) > 10 || t.mesh.position.z > 5) {
                                scene.remove(t.mesh);
                                gameData.current.targets = []; 
                                addFloatingText("MISSED!!!", "text-red-1000");
                                AudioEngine.play(150, 'sawtooth', 0.3, 0.05);
                                spawnTarget(); 
                            }
                        }

                        renderer.render(scene, camera);
                    }
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }, [gameState]);

            const spawnTarget = () => {
                if (gameData.current.targets.length > 0) return; 

                const isMystery = Math.random() < 0.2; 
                setCurrentTargetType(isMystery ? 'mystery' : 'std');

                
                const randomGeoIndex = Math.floor(Math.random() * geometryCreators.length);
                const geo = geometryCreators[randomGeoIndex]();

                const mat = new THREE.MeshPhongMaterial({ 
                    color: isMystery ? 0xffff00 : 0x00ffff, 
                    emissive: isMystery ? 0xff00ff : 0x004444,
                    shininess: 150, flatShading: true 
                });
                const mesh = new THREE.Mesh(geo, mat);

                
                const side = Math.floor(Math.random() * 4);
                const rangeX = 14; const rangeY = 9;
                let startX, startY;
                if(side===0){startX=(Math.random()-0.5)*rangeX;startY=rangeY;}
                else if(side===1){startX=(Math.random()-0.5)*rangeX;startY=-rangeY;}
                else if(side===2){startX=-rangeX;startY=(Math.random()-0.5)*rangeY;}
                else{startX=rangeX;startY=(Math.random()-0.5)*rangeY;}

                mesh.position.set(startX, startY, -18);
                
                
                const targetPos = new THREE.Vector3((Math.random()-0.5)*6, (Math.random()-0.5)*4, 0);
                const direction = new THREE.Vector3().subVectors(targetPos, mesh.position).normalize();
                const speed = isMystery ? 0.1 : 0.05; 
                
                gameData.current.targets.push({ mesh, type: isMystery ? 'mystery' : 'std', velocity: direction.multiplyScalar(speed) });
                sceneRef.current.scene.add(mesh);
            };

            const shoot = () => {
                AudioEngine.play(500, 'square', 0.05, 0.05);
                if (gameData.current.targets.length === 0) return;

                const { camera, raycaster, scene } = sceneRef.current;
                const ndc = new THREE.Vector2((gameData.current.smoothedAim.x * 2) - 1, -(gameData.current.smoothedAim.y * 2) + 1);
                raycaster.setFromCamera(ndc, camera);
                
                const target = gameData.current.targets[0];
                const intersects = raycaster.intersectObject(target.mesh);

                if (intersects.length > 0) {
                    const pts = target.type === 'mystery' ? 500 : 100;
                    setScore(prev => prev + pts);
                    AudioEngine.play(target.type === 'mystery' ? 1200 : 600, 'sine', 0.2, 0.2);
                    
                    
                    const explosionLoop = () => {
                        target.mesh.scale.multiplyScalar(1.2);
                        target.mesh.material.opacity -= 0.1;
                        target.mesh.material.transparent = true;
                        if (target.mesh.scale.x < 3) requestAnimationFrame(explosionLoop);
                        else {
                             scene.remove(target.mesh);
                             gameData.current.targets = [];
                             spawnTarget(); 
                        }
                    }
                    explosionLoop();
                    addFloatingText(`+${pts}`, target.type === 'mystery' ? "text-yellow-400" : "text-cyan-400");
                }
            };

            const addFloatingText = (txt, cls) => {
                const id = Date.now();
                setFloatingTexts(p => [...p, { id, txt, cls, x: gameData.current.smoothedAim.x*100, y: gameData.current.smoothedAim.y*100 }]);
                setTimeout(() => setFloatingTexts(p => p.filter(f => f.id !== id)), 800);
            };

            return (
                <div className="fixed inset-0 z-20 pointer-events-none select-none">
                    <div className="absolute top-8 w-full px-12 flex justify-between items-start">
                        <div className="bg-black/50 p-4 border-l-4 border-purple-500">
                            <div className="text-xs opacity-60 text-purple-300">TOTAL SCORE</div>
                            <div className="text-5xl font-black text-purple-400 neon-text">{score.toLocaleString()}</div>
                        </div>
                        <div className="text-right">
                            <div className="text-xl font-bold text-cyan-400 neon-text tracking-widest">ONE SHOT MODE</div>
                            {CurrentTargetType === 'mystery' && <div className="text-yellow-400 animate-pulse font-bold">‚ö† MYSTERY TARGET ‚ö†</div>}
                        </div>
                    </div>

                    <div className="absolute border-2 border-white/60 rounded-full w-12 h-12 -ml-6 -mt-6 flex items-center justify-center transition-all"
                         style={{ 
                            left: `${gameData.current.smoothedAim.x*100}%`, top: `${gameData.current.smoothedAim.y*100}%`,
                            borderColor: gameData.current.isFiring ? '#f0f' : '#0ff',
                            transform: gameData.current.isFiring ? 'scale(0.8)' : 'scale(1)'
                         }}>
                        <div className={`w-2 h-2 rounded-full ${gameData.current.isFiring ? 'bg-magenta-500' : 'bg-cyan-500'}`}></div>
                    </div>

                    {gameState !== 'playing' && (
                        <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center pointer-events-auto text-center px-4">
                            <h1 className="text-6xl font-black mb-2 tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 neon-text">CYBER_SHOT</h1>
                            <h2 className="text-xl mb-8 tracking-widest text-purple-300">CYBER_Shot - Random Shapes</h2>
                            {gameState === 'loading' ? <p className="animate-pulse">Loading Modules...</p> : (
                                <div>
                                    <p className="text-2xl mb-4">MAKE A <span className="text-cyan-400 font-bold">PISTOL GESTURE üî´</span></p>
									<p className="text-xl mb-6">GI∆† TAY H√åNH <span className="text-yellow-400">KH·∫®U S√öNG üî´</span> ƒê·ªÇ B·∫ÆT ƒê·∫¶U</p>
                                    <div className="w-64 h-3 bg-gray-800 rounded-full overflow-hidden border border-gray-600">
                                        <div className="h-full bg-gradient-to-r from-cyan-500 to-purple-500 transition-all" style={{ width: `${gameData.current.calibration*66}%` }}></div>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                    {floatingTexts.map(f => <div key={f.id} className={`floating-text ${f.cls}`} style={{left:`${f.x}%`, top:`${f.y}%`}}>{f.txt}</div>)}
					<div className="absolute bottom-6 w-full text-center pointer-events-auto">
                        <a href="https://xedichvunguyenhoang.com" target="_blank" className="text-[20px] opacity-30 hover:opacity-100 tracking-[0.5em]">Nguy·ªÖn ƒê√¨nh Anh Ho√†ng - ICT Teacher</a>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<App />);
    </script>
</body>
</html>